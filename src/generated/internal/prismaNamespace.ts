
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
export const prismaVersion: PrismaVersion = {
  client: "7.3.0",
  engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  agendamentos: 'agendamentos',
  cartoes_kanban: 'cartoes_kanban',
  categorias_servico: 'categorias_servico',
  clientes: 'clientes',
  colunas_kanban: 'colunas_kanban',
  configuracoes_sistema: 'configuracoes_sistema',
  faturas: 'faturas',
  fornecedores: 'fornecedores',
  historico_cartao_kanban: 'historico_cartao_kanban',
  itens_fatura: 'itens_fatura',
  itens_orcamento: 'itens_orcamento',
  itens_ordem_trabalho: 'itens_ordem_trabalho',
  log_auditoria: 'log_auditoria',
  mecanicos: 'mecanicos',
  orcamentos: 'orcamentos',
  ordens_trabalho: 'ordens_trabalho',
  pagamentos: 'pagamentos',
  pecas: 'pecas',
  pecas_ordem_trabalho: 'pecas_ordem_trabalho',
  servicos: 'servicos',
  transacoes_pecas: 'transacoes_pecas',
  utilizadores: 'utilizadores',
  veiculos: 'veiculos'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "agendamentos" | "cartoes_kanban" | "categorias_servico" | "clientes" | "colunas_kanban" | "configuracoes_sistema" | "faturas" | "fornecedores" | "historico_cartao_kanban" | "itens_fatura" | "itens_orcamento" | "itens_ordem_trabalho" | "log_auditoria" | "mecanicos" | "orcamentos" | "ordens_trabalho" | "pagamentos" | "pecas" | "pecas_ordem_trabalho" | "servicos" | "transacoes_pecas" | "utilizadores" | "veiculos"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    agendamentos: {
      payload: Prisma.$agendamentosPayload<ExtArgs>
      fields: Prisma.agendamentosFieldRefs
      operations: {
        findUnique: {
          args: Prisma.agendamentosFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agendamentosPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.agendamentosFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agendamentosPayload>
        }
        findFirst: {
          args: Prisma.agendamentosFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agendamentosPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.agendamentosFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agendamentosPayload>
        }
        findMany: {
          args: Prisma.agendamentosFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agendamentosPayload>[]
        }
        create: {
          args: Prisma.agendamentosCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agendamentosPayload>
        }
        createMany: {
          args: Prisma.agendamentosCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.agendamentosDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agendamentosPayload>
        }
        update: {
          args: Prisma.agendamentosUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agendamentosPayload>
        }
        deleteMany: {
          args: Prisma.agendamentosDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.agendamentosUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.agendamentosUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agendamentosPayload>
        }
        aggregate: {
          args: Prisma.AgendamentosAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAgendamentos>
        }
        groupBy: {
          args: Prisma.agendamentosGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AgendamentosGroupByOutputType>[]
        }
        count: {
          args: Prisma.agendamentosCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AgendamentosCountAggregateOutputType> | number
        }
      }
    }
    cartoes_kanban: {
      payload: Prisma.$cartoes_kanbanPayload<ExtArgs>
      fields: Prisma.cartoes_kanbanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.cartoes_kanbanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cartoes_kanbanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.cartoes_kanbanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cartoes_kanbanPayload>
        }
        findFirst: {
          args: Prisma.cartoes_kanbanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cartoes_kanbanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.cartoes_kanbanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cartoes_kanbanPayload>
        }
        findMany: {
          args: Prisma.cartoes_kanbanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cartoes_kanbanPayload>[]
        }
        create: {
          args: Prisma.cartoes_kanbanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cartoes_kanbanPayload>
        }
        createMany: {
          args: Prisma.cartoes_kanbanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.cartoes_kanbanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cartoes_kanbanPayload>
        }
        update: {
          args: Prisma.cartoes_kanbanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cartoes_kanbanPayload>
        }
        deleteMany: {
          args: Prisma.cartoes_kanbanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.cartoes_kanbanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.cartoes_kanbanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cartoes_kanbanPayload>
        }
        aggregate: {
          args: Prisma.Cartoes_kanbanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCartoes_kanban>
        }
        groupBy: {
          args: Prisma.cartoes_kanbanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Cartoes_kanbanGroupByOutputType>[]
        }
        count: {
          args: Prisma.cartoes_kanbanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Cartoes_kanbanCountAggregateOutputType> | number
        }
      }
    }
    categorias_servico: {
      payload: Prisma.$categorias_servicoPayload<ExtArgs>
      fields: Prisma.categorias_servicoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.categorias_servicoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categorias_servicoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.categorias_servicoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categorias_servicoPayload>
        }
        findFirst: {
          args: Prisma.categorias_servicoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categorias_servicoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.categorias_servicoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categorias_servicoPayload>
        }
        findMany: {
          args: Prisma.categorias_servicoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categorias_servicoPayload>[]
        }
        create: {
          args: Prisma.categorias_servicoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categorias_servicoPayload>
        }
        createMany: {
          args: Prisma.categorias_servicoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.categorias_servicoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categorias_servicoPayload>
        }
        update: {
          args: Prisma.categorias_servicoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categorias_servicoPayload>
        }
        deleteMany: {
          args: Prisma.categorias_servicoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.categorias_servicoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.categorias_servicoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$categorias_servicoPayload>
        }
        aggregate: {
          args: Prisma.Categorias_servicoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategorias_servico>
        }
        groupBy: {
          args: Prisma.categorias_servicoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Categorias_servicoGroupByOutputType>[]
        }
        count: {
          args: Prisma.categorias_servicoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Categorias_servicoCountAggregateOutputType> | number
        }
      }
    }
    clientes: {
      payload: Prisma.$clientesPayload<ExtArgs>
      fields: Prisma.clientesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.clientesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clientesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.clientesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clientesPayload>
        }
        findFirst: {
          args: Prisma.clientesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clientesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.clientesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clientesPayload>
        }
        findMany: {
          args: Prisma.clientesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clientesPayload>[]
        }
        create: {
          args: Prisma.clientesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clientesPayload>
        }
        createMany: {
          args: Prisma.clientesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.clientesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clientesPayload>
        }
        update: {
          args: Prisma.clientesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clientesPayload>
        }
        deleteMany: {
          args: Prisma.clientesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.clientesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.clientesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clientesPayload>
        }
        aggregate: {
          args: Prisma.ClientesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateClientes>
        }
        groupBy: {
          args: Prisma.clientesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClientesGroupByOutputType>[]
        }
        count: {
          args: Prisma.clientesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClientesCountAggregateOutputType> | number
        }
      }
    }
    colunas_kanban: {
      payload: Prisma.$colunas_kanbanPayload<ExtArgs>
      fields: Prisma.colunas_kanbanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.colunas_kanbanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$colunas_kanbanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.colunas_kanbanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$colunas_kanbanPayload>
        }
        findFirst: {
          args: Prisma.colunas_kanbanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$colunas_kanbanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.colunas_kanbanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$colunas_kanbanPayload>
        }
        findMany: {
          args: Prisma.colunas_kanbanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$colunas_kanbanPayload>[]
        }
        create: {
          args: Prisma.colunas_kanbanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$colunas_kanbanPayload>
        }
        createMany: {
          args: Prisma.colunas_kanbanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.colunas_kanbanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$colunas_kanbanPayload>
        }
        update: {
          args: Prisma.colunas_kanbanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$colunas_kanbanPayload>
        }
        deleteMany: {
          args: Prisma.colunas_kanbanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.colunas_kanbanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.colunas_kanbanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$colunas_kanbanPayload>
        }
        aggregate: {
          args: Prisma.Colunas_kanbanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateColunas_kanban>
        }
        groupBy: {
          args: Prisma.colunas_kanbanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Colunas_kanbanGroupByOutputType>[]
        }
        count: {
          args: Prisma.colunas_kanbanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Colunas_kanbanCountAggregateOutputType> | number
        }
      }
    }
    configuracoes_sistema: {
      payload: Prisma.$configuracoes_sistemaPayload<ExtArgs>
      fields: Prisma.configuracoes_sistemaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.configuracoes_sistemaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$configuracoes_sistemaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.configuracoes_sistemaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$configuracoes_sistemaPayload>
        }
        findFirst: {
          args: Prisma.configuracoes_sistemaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$configuracoes_sistemaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.configuracoes_sistemaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$configuracoes_sistemaPayload>
        }
        findMany: {
          args: Prisma.configuracoes_sistemaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$configuracoes_sistemaPayload>[]
        }
        create: {
          args: Prisma.configuracoes_sistemaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$configuracoes_sistemaPayload>
        }
        createMany: {
          args: Prisma.configuracoes_sistemaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.configuracoes_sistemaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$configuracoes_sistemaPayload>
        }
        update: {
          args: Prisma.configuracoes_sistemaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$configuracoes_sistemaPayload>
        }
        deleteMany: {
          args: Prisma.configuracoes_sistemaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.configuracoes_sistemaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.configuracoes_sistemaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$configuracoes_sistemaPayload>
        }
        aggregate: {
          args: Prisma.Configuracoes_sistemaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConfiguracoes_sistema>
        }
        groupBy: {
          args: Prisma.configuracoes_sistemaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Configuracoes_sistemaGroupByOutputType>[]
        }
        count: {
          args: Prisma.configuracoes_sistemaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Configuracoes_sistemaCountAggregateOutputType> | number
        }
      }
    }
    faturas: {
      payload: Prisma.$faturasPayload<ExtArgs>
      fields: Prisma.faturasFieldRefs
      operations: {
        findUnique: {
          args: Prisma.faturasFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$faturasPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.faturasFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$faturasPayload>
        }
        findFirst: {
          args: Prisma.faturasFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$faturasPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.faturasFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$faturasPayload>
        }
        findMany: {
          args: Prisma.faturasFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$faturasPayload>[]
        }
        create: {
          args: Prisma.faturasCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$faturasPayload>
        }
        createMany: {
          args: Prisma.faturasCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.faturasDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$faturasPayload>
        }
        update: {
          args: Prisma.faturasUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$faturasPayload>
        }
        deleteMany: {
          args: Prisma.faturasDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.faturasUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.faturasUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$faturasPayload>
        }
        aggregate: {
          args: Prisma.FaturasAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFaturas>
        }
        groupBy: {
          args: Prisma.faturasGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FaturasGroupByOutputType>[]
        }
        count: {
          args: Prisma.faturasCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FaturasCountAggregateOutputType> | number
        }
      }
    }
    fornecedores: {
      payload: Prisma.$fornecedoresPayload<ExtArgs>
      fields: Prisma.fornecedoresFieldRefs
      operations: {
        findUnique: {
          args: Prisma.fornecedoresFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$fornecedoresPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.fornecedoresFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$fornecedoresPayload>
        }
        findFirst: {
          args: Prisma.fornecedoresFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$fornecedoresPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.fornecedoresFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$fornecedoresPayload>
        }
        findMany: {
          args: Prisma.fornecedoresFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$fornecedoresPayload>[]
        }
        create: {
          args: Prisma.fornecedoresCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$fornecedoresPayload>
        }
        createMany: {
          args: Prisma.fornecedoresCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.fornecedoresDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$fornecedoresPayload>
        }
        update: {
          args: Prisma.fornecedoresUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$fornecedoresPayload>
        }
        deleteMany: {
          args: Prisma.fornecedoresDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.fornecedoresUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.fornecedoresUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$fornecedoresPayload>
        }
        aggregate: {
          args: Prisma.FornecedoresAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFornecedores>
        }
        groupBy: {
          args: Prisma.fornecedoresGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FornecedoresGroupByOutputType>[]
        }
        count: {
          args: Prisma.fornecedoresCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FornecedoresCountAggregateOutputType> | number
        }
      }
    }
    historico_cartao_kanban: {
      payload: Prisma.$historico_cartao_kanbanPayload<ExtArgs>
      fields: Prisma.historico_cartao_kanbanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.historico_cartao_kanbanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$historico_cartao_kanbanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.historico_cartao_kanbanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$historico_cartao_kanbanPayload>
        }
        findFirst: {
          args: Prisma.historico_cartao_kanbanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$historico_cartao_kanbanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.historico_cartao_kanbanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$historico_cartao_kanbanPayload>
        }
        findMany: {
          args: Prisma.historico_cartao_kanbanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$historico_cartao_kanbanPayload>[]
        }
        create: {
          args: Prisma.historico_cartao_kanbanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$historico_cartao_kanbanPayload>
        }
        createMany: {
          args: Prisma.historico_cartao_kanbanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.historico_cartao_kanbanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$historico_cartao_kanbanPayload>
        }
        update: {
          args: Prisma.historico_cartao_kanbanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$historico_cartao_kanbanPayload>
        }
        deleteMany: {
          args: Prisma.historico_cartao_kanbanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.historico_cartao_kanbanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.historico_cartao_kanbanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$historico_cartao_kanbanPayload>
        }
        aggregate: {
          args: Prisma.Historico_cartao_kanbanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHistorico_cartao_kanban>
        }
        groupBy: {
          args: Prisma.historico_cartao_kanbanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Historico_cartao_kanbanGroupByOutputType>[]
        }
        count: {
          args: Prisma.historico_cartao_kanbanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Historico_cartao_kanbanCountAggregateOutputType> | number
        }
      }
    }
    itens_fatura: {
      payload: Prisma.$itens_faturaPayload<ExtArgs>
      fields: Prisma.itens_faturaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.itens_faturaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_faturaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.itens_faturaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_faturaPayload>
        }
        findFirst: {
          args: Prisma.itens_faturaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_faturaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.itens_faturaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_faturaPayload>
        }
        findMany: {
          args: Prisma.itens_faturaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_faturaPayload>[]
        }
        create: {
          args: Prisma.itens_faturaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_faturaPayload>
        }
        createMany: {
          args: Prisma.itens_faturaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.itens_faturaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_faturaPayload>
        }
        update: {
          args: Prisma.itens_faturaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_faturaPayload>
        }
        deleteMany: {
          args: Prisma.itens_faturaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.itens_faturaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.itens_faturaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_faturaPayload>
        }
        aggregate: {
          args: Prisma.Itens_faturaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateItens_fatura>
        }
        groupBy: {
          args: Prisma.itens_faturaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Itens_faturaGroupByOutputType>[]
        }
        count: {
          args: Prisma.itens_faturaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Itens_faturaCountAggregateOutputType> | number
        }
      }
    }
    itens_orcamento: {
      payload: Prisma.$itens_orcamentoPayload<ExtArgs>
      fields: Prisma.itens_orcamentoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.itens_orcamentoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_orcamentoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.itens_orcamentoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_orcamentoPayload>
        }
        findFirst: {
          args: Prisma.itens_orcamentoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_orcamentoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.itens_orcamentoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_orcamentoPayload>
        }
        findMany: {
          args: Prisma.itens_orcamentoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_orcamentoPayload>[]
        }
        create: {
          args: Prisma.itens_orcamentoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_orcamentoPayload>
        }
        createMany: {
          args: Prisma.itens_orcamentoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.itens_orcamentoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_orcamentoPayload>
        }
        update: {
          args: Prisma.itens_orcamentoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_orcamentoPayload>
        }
        deleteMany: {
          args: Prisma.itens_orcamentoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.itens_orcamentoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.itens_orcamentoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_orcamentoPayload>
        }
        aggregate: {
          args: Prisma.Itens_orcamentoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateItens_orcamento>
        }
        groupBy: {
          args: Prisma.itens_orcamentoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Itens_orcamentoGroupByOutputType>[]
        }
        count: {
          args: Prisma.itens_orcamentoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Itens_orcamentoCountAggregateOutputType> | number
        }
      }
    }
    itens_ordem_trabalho: {
      payload: Prisma.$itens_ordem_trabalhoPayload<ExtArgs>
      fields: Prisma.itens_ordem_trabalhoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.itens_ordem_trabalhoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_ordem_trabalhoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.itens_ordem_trabalhoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_ordem_trabalhoPayload>
        }
        findFirst: {
          args: Prisma.itens_ordem_trabalhoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_ordem_trabalhoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.itens_ordem_trabalhoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_ordem_trabalhoPayload>
        }
        findMany: {
          args: Prisma.itens_ordem_trabalhoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_ordem_trabalhoPayload>[]
        }
        create: {
          args: Prisma.itens_ordem_trabalhoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_ordem_trabalhoPayload>
        }
        createMany: {
          args: Prisma.itens_ordem_trabalhoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.itens_ordem_trabalhoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_ordem_trabalhoPayload>
        }
        update: {
          args: Prisma.itens_ordem_trabalhoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_ordem_trabalhoPayload>
        }
        deleteMany: {
          args: Prisma.itens_ordem_trabalhoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.itens_ordem_trabalhoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.itens_ordem_trabalhoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$itens_ordem_trabalhoPayload>
        }
        aggregate: {
          args: Prisma.Itens_ordem_trabalhoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateItens_ordem_trabalho>
        }
        groupBy: {
          args: Prisma.itens_ordem_trabalhoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Itens_ordem_trabalhoGroupByOutputType>[]
        }
        count: {
          args: Prisma.itens_ordem_trabalhoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Itens_ordem_trabalhoCountAggregateOutputType> | number
        }
      }
    }
    log_auditoria: {
      payload: Prisma.$log_auditoriaPayload<ExtArgs>
      fields: Prisma.log_auditoriaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.log_auditoriaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$log_auditoriaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.log_auditoriaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$log_auditoriaPayload>
        }
        findFirst: {
          args: Prisma.log_auditoriaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$log_auditoriaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.log_auditoriaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$log_auditoriaPayload>
        }
        findMany: {
          args: Prisma.log_auditoriaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$log_auditoriaPayload>[]
        }
        create: {
          args: Prisma.log_auditoriaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$log_auditoriaPayload>
        }
        createMany: {
          args: Prisma.log_auditoriaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.log_auditoriaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$log_auditoriaPayload>
        }
        update: {
          args: Prisma.log_auditoriaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$log_auditoriaPayload>
        }
        deleteMany: {
          args: Prisma.log_auditoriaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.log_auditoriaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.log_auditoriaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$log_auditoriaPayload>
        }
        aggregate: {
          args: Prisma.Log_auditoriaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLog_auditoria>
        }
        groupBy: {
          args: Prisma.log_auditoriaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Log_auditoriaGroupByOutputType>[]
        }
        count: {
          args: Prisma.log_auditoriaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Log_auditoriaCountAggregateOutputType> | number
        }
      }
    }
    mecanicos: {
      payload: Prisma.$mecanicosPayload<ExtArgs>
      fields: Prisma.mecanicosFieldRefs
      operations: {
        findUnique: {
          args: Prisma.mecanicosFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$mecanicosPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.mecanicosFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$mecanicosPayload>
        }
        findFirst: {
          args: Prisma.mecanicosFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$mecanicosPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.mecanicosFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$mecanicosPayload>
        }
        findMany: {
          args: Prisma.mecanicosFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$mecanicosPayload>[]
        }
        create: {
          args: Prisma.mecanicosCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$mecanicosPayload>
        }
        createMany: {
          args: Prisma.mecanicosCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.mecanicosDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$mecanicosPayload>
        }
        update: {
          args: Prisma.mecanicosUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$mecanicosPayload>
        }
        deleteMany: {
          args: Prisma.mecanicosDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.mecanicosUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.mecanicosUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$mecanicosPayload>
        }
        aggregate: {
          args: Prisma.MecanicosAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMecanicos>
        }
        groupBy: {
          args: Prisma.mecanicosGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MecanicosGroupByOutputType>[]
        }
        count: {
          args: Prisma.mecanicosCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MecanicosCountAggregateOutputType> | number
        }
      }
    }
    orcamentos: {
      payload: Prisma.$orcamentosPayload<ExtArgs>
      fields: Prisma.orcamentosFieldRefs
      operations: {
        findUnique: {
          args: Prisma.orcamentosFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$orcamentosPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.orcamentosFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$orcamentosPayload>
        }
        findFirst: {
          args: Prisma.orcamentosFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$orcamentosPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.orcamentosFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$orcamentosPayload>
        }
        findMany: {
          args: Prisma.orcamentosFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$orcamentosPayload>[]
        }
        create: {
          args: Prisma.orcamentosCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$orcamentosPayload>
        }
        createMany: {
          args: Prisma.orcamentosCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.orcamentosDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$orcamentosPayload>
        }
        update: {
          args: Prisma.orcamentosUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$orcamentosPayload>
        }
        deleteMany: {
          args: Prisma.orcamentosDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.orcamentosUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.orcamentosUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$orcamentosPayload>
        }
        aggregate: {
          args: Prisma.OrcamentosAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrcamentos>
        }
        groupBy: {
          args: Prisma.orcamentosGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrcamentosGroupByOutputType>[]
        }
        count: {
          args: Prisma.orcamentosCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrcamentosCountAggregateOutputType> | number
        }
      }
    }
    ordens_trabalho: {
      payload: Prisma.$ordens_trabalhoPayload<ExtArgs>
      fields: Prisma.ordens_trabalhoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ordens_trabalhoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ordens_trabalhoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ordens_trabalhoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ordens_trabalhoPayload>
        }
        findFirst: {
          args: Prisma.ordens_trabalhoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ordens_trabalhoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ordens_trabalhoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ordens_trabalhoPayload>
        }
        findMany: {
          args: Prisma.ordens_trabalhoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ordens_trabalhoPayload>[]
        }
        create: {
          args: Prisma.ordens_trabalhoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ordens_trabalhoPayload>
        }
        createMany: {
          args: Prisma.ordens_trabalhoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ordens_trabalhoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ordens_trabalhoPayload>
        }
        update: {
          args: Prisma.ordens_trabalhoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ordens_trabalhoPayload>
        }
        deleteMany: {
          args: Prisma.ordens_trabalhoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ordens_trabalhoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ordens_trabalhoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ordens_trabalhoPayload>
        }
        aggregate: {
          args: Prisma.Ordens_trabalhoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrdens_trabalho>
        }
        groupBy: {
          args: Prisma.ordens_trabalhoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Ordens_trabalhoGroupByOutputType>[]
        }
        count: {
          args: Prisma.ordens_trabalhoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Ordens_trabalhoCountAggregateOutputType> | number
        }
      }
    }
    pagamentos: {
      payload: Prisma.$pagamentosPayload<ExtArgs>
      fields: Prisma.pagamentosFieldRefs
      operations: {
        findUnique: {
          args: Prisma.pagamentosFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pagamentosPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.pagamentosFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pagamentosPayload>
        }
        findFirst: {
          args: Prisma.pagamentosFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pagamentosPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.pagamentosFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pagamentosPayload>
        }
        findMany: {
          args: Prisma.pagamentosFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pagamentosPayload>[]
        }
        create: {
          args: Prisma.pagamentosCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pagamentosPayload>
        }
        createMany: {
          args: Prisma.pagamentosCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.pagamentosDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pagamentosPayload>
        }
        update: {
          args: Prisma.pagamentosUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pagamentosPayload>
        }
        deleteMany: {
          args: Prisma.pagamentosDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.pagamentosUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.pagamentosUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pagamentosPayload>
        }
        aggregate: {
          args: Prisma.PagamentosAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePagamentos>
        }
        groupBy: {
          args: Prisma.pagamentosGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PagamentosGroupByOutputType>[]
        }
        count: {
          args: Prisma.pagamentosCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PagamentosCountAggregateOutputType> | number
        }
      }
    }
    pecas: {
      payload: Prisma.$pecasPayload<ExtArgs>
      fields: Prisma.pecasFieldRefs
      operations: {
        findUnique: {
          args: Prisma.pecasFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecasPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.pecasFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecasPayload>
        }
        findFirst: {
          args: Prisma.pecasFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecasPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.pecasFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecasPayload>
        }
        findMany: {
          args: Prisma.pecasFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecasPayload>[]
        }
        create: {
          args: Prisma.pecasCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecasPayload>
        }
        createMany: {
          args: Prisma.pecasCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.pecasDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecasPayload>
        }
        update: {
          args: Prisma.pecasUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecasPayload>
        }
        deleteMany: {
          args: Prisma.pecasDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.pecasUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.pecasUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecasPayload>
        }
        aggregate: {
          args: Prisma.PecasAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePecas>
        }
        groupBy: {
          args: Prisma.pecasGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PecasGroupByOutputType>[]
        }
        count: {
          args: Prisma.pecasCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PecasCountAggregateOutputType> | number
        }
      }
    }
    pecas_ordem_trabalho: {
      payload: Prisma.$pecas_ordem_trabalhoPayload<ExtArgs>
      fields: Prisma.pecas_ordem_trabalhoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.pecas_ordem_trabalhoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecas_ordem_trabalhoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.pecas_ordem_trabalhoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecas_ordem_trabalhoPayload>
        }
        findFirst: {
          args: Prisma.pecas_ordem_trabalhoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecas_ordem_trabalhoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.pecas_ordem_trabalhoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecas_ordem_trabalhoPayload>
        }
        findMany: {
          args: Prisma.pecas_ordem_trabalhoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecas_ordem_trabalhoPayload>[]
        }
        create: {
          args: Prisma.pecas_ordem_trabalhoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecas_ordem_trabalhoPayload>
        }
        createMany: {
          args: Prisma.pecas_ordem_trabalhoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.pecas_ordem_trabalhoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecas_ordem_trabalhoPayload>
        }
        update: {
          args: Prisma.pecas_ordem_trabalhoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecas_ordem_trabalhoPayload>
        }
        deleteMany: {
          args: Prisma.pecas_ordem_trabalhoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.pecas_ordem_trabalhoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.pecas_ordem_trabalhoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$pecas_ordem_trabalhoPayload>
        }
        aggregate: {
          args: Prisma.Pecas_ordem_trabalhoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePecas_ordem_trabalho>
        }
        groupBy: {
          args: Prisma.pecas_ordem_trabalhoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Pecas_ordem_trabalhoGroupByOutputType>[]
        }
        count: {
          args: Prisma.pecas_ordem_trabalhoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Pecas_ordem_trabalhoCountAggregateOutputType> | number
        }
      }
    }
    servicos: {
      payload: Prisma.$servicosPayload<ExtArgs>
      fields: Prisma.servicosFieldRefs
      operations: {
        findUnique: {
          args: Prisma.servicosFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$servicosPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.servicosFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$servicosPayload>
        }
        findFirst: {
          args: Prisma.servicosFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$servicosPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.servicosFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$servicosPayload>
        }
        findMany: {
          args: Prisma.servicosFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$servicosPayload>[]
        }
        create: {
          args: Prisma.servicosCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$servicosPayload>
        }
        createMany: {
          args: Prisma.servicosCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.servicosDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$servicosPayload>
        }
        update: {
          args: Prisma.servicosUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$servicosPayload>
        }
        deleteMany: {
          args: Prisma.servicosDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.servicosUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.servicosUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$servicosPayload>
        }
        aggregate: {
          args: Prisma.ServicosAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServicos>
        }
        groupBy: {
          args: Prisma.servicosGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicosGroupByOutputType>[]
        }
        count: {
          args: Prisma.servicosCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicosCountAggregateOutputType> | number
        }
      }
    }
    transacoes_pecas: {
      payload: Prisma.$transacoes_pecasPayload<ExtArgs>
      fields: Prisma.transacoes_pecasFieldRefs
      operations: {
        findUnique: {
          args: Prisma.transacoes_pecasFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$transacoes_pecasPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.transacoes_pecasFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$transacoes_pecasPayload>
        }
        findFirst: {
          args: Prisma.transacoes_pecasFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$transacoes_pecasPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.transacoes_pecasFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$transacoes_pecasPayload>
        }
        findMany: {
          args: Prisma.transacoes_pecasFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$transacoes_pecasPayload>[]
        }
        create: {
          args: Prisma.transacoes_pecasCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$transacoes_pecasPayload>
        }
        createMany: {
          args: Prisma.transacoes_pecasCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.transacoes_pecasDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$transacoes_pecasPayload>
        }
        update: {
          args: Prisma.transacoes_pecasUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$transacoes_pecasPayload>
        }
        deleteMany: {
          args: Prisma.transacoes_pecasDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.transacoes_pecasUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.transacoes_pecasUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$transacoes_pecasPayload>
        }
        aggregate: {
          args: Prisma.Transacoes_pecasAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransacoes_pecas>
        }
        groupBy: {
          args: Prisma.transacoes_pecasGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Transacoes_pecasGroupByOutputType>[]
        }
        count: {
          args: Prisma.transacoes_pecasCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Transacoes_pecasCountAggregateOutputType> | number
        }
      }
    }
    utilizadores: {
      payload: Prisma.$utilizadoresPayload<ExtArgs>
      fields: Prisma.utilizadoresFieldRefs
      operations: {
        findUnique: {
          args: Prisma.utilizadoresFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$utilizadoresPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.utilizadoresFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$utilizadoresPayload>
        }
        findFirst: {
          args: Prisma.utilizadoresFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$utilizadoresPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.utilizadoresFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$utilizadoresPayload>
        }
        findMany: {
          args: Prisma.utilizadoresFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$utilizadoresPayload>[]
        }
        create: {
          args: Prisma.utilizadoresCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$utilizadoresPayload>
        }
        createMany: {
          args: Prisma.utilizadoresCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.utilizadoresDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$utilizadoresPayload>
        }
        update: {
          args: Prisma.utilizadoresUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$utilizadoresPayload>
        }
        deleteMany: {
          args: Prisma.utilizadoresDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.utilizadoresUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.utilizadoresUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$utilizadoresPayload>
        }
        aggregate: {
          args: Prisma.UtilizadoresAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUtilizadores>
        }
        groupBy: {
          args: Prisma.utilizadoresGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UtilizadoresGroupByOutputType>[]
        }
        count: {
          args: Prisma.utilizadoresCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UtilizadoresCountAggregateOutputType> | number
        }
      }
    }
    veiculos: {
      payload: Prisma.$veiculosPayload<ExtArgs>
      fields: Prisma.veiculosFieldRefs
      operations: {
        findUnique: {
          args: Prisma.veiculosFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$veiculosPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.veiculosFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$veiculosPayload>
        }
        findFirst: {
          args: Prisma.veiculosFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$veiculosPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.veiculosFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$veiculosPayload>
        }
        findMany: {
          args: Prisma.veiculosFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$veiculosPayload>[]
        }
        create: {
          args: Prisma.veiculosCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$veiculosPayload>
        }
        createMany: {
          args: Prisma.veiculosCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.veiculosDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$veiculosPayload>
        }
        update: {
          args: Prisma.veiculosUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$veiculosPayload>
        }
        deleteMany: {
          args: Prisma.veiculosDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.veiculosUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.veiculosUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$veiculosPayload>
        }
        aggregate: {
          args: Prisma.VeiculosAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVeiculos>
        }
        groupBy: {
          args: Prisma.veiculosGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VeiculosGroupByOutputType>[]
        }
        count: {
          args: Prisma.veiculosCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VeiculosCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const AgendamentosScalarFieldEnum = {
  id: 'id',
  cliente_id: 'cliente_id',
  veiculo_id: 'veiculo_id',
  mecanico_id: 'mecanico_id',
  servico_id: 'servico_id',
  titulo: 'titulo',
  descricao: 'descricao',
  data_agendamento: 'data_agendamento',
  hora_inicio: 'hora_inicio',
  hora_fim: 'hora_fim',
  estado: 'estado',
  prioridade: 'prioridade',
  custo_estimado: 'custo_estimado',
  notas: 'notas',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em',
  criado_por: 'criado_por',
  atualizado_por: 'atualizado_por'
} as const

export type AgendamentosScalarFieldEnum = (typeof AgendamentosScalarFieldEnum)[keyof typeof AgendamentosScalarFieldEnum]


export const Cartoes_kanbanScalarFieldEnum = {
  id: 'id',
  coluna_id: 'coluna_id',
  ordem_trabalho_id: 'ordem_trabalho_id',
  titulo: 'titulo',
  descricao: 'descricao',
  prioridade: 'prioridade',
  atribuido_a: 'atribuido_a',
  data_limite: 'data_limite',
  etiquetas: 'etiquetas',
  posicao: 'posicao',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em',
  criado_por: 'criado_por',
  atualizado_por: 'atualizado_por'
} as const

export type Cartoes_kanbanScalarFieldEnum = (typeof Cartoes_kanbanScalarFieldEnum)[keyof typeof Cartoes_kanbanScalarFieldEnum]


export const Categorias_servicoScalarFieldEnum = {
  id: 'id',
  nome: 'nome',
  descricao: 'descricao',
  duracao_estimada: 'duracao_estimada',
  ativo: 'ativo',
  criado_em: 'criado_em'
} as const

export type Categorias_servicoScalarFieldEnum = (typeof Categorias_servicoScalarFieldEnum)[keyof typeof Categorias_servicoScalarFieldEnum]


export const ClientesScalarFieldEnum = {
  id: 'id',
  nome: 'nome',
  email: 'email',
  telefone: 'telefone',
  nif: 'nif',
  endereco: 'endereco',
  perfil: 'perfil',
  data_registo: 'data_registo',
  total_gasto: 'total_gasto',
  visitas: 'visitas',
  notas: 'notas',
  ativo: 'ativo',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em'
} as const

export type ClientesScalarFieldEnum = (typeof ClientesScalarFieldEnum)[keyof typeof ClientesScalarFieldEnum]


export const Colunas_kanbanScalarFieldEnum = {
  id: 'id',
  nome: 'nome',
  descricao: 'descricao',
  posicao: 'posicao',
  cor: 'cor',
  ativo: 'ativo',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em'
} as const

export type Colunas_kanbanScalarFieldEnum = (typeof Colunas_kanbanScalarFieldEnum)[keyof typeof Colunas_kanbanScalarFieldEnum]


export const Configuracoes_sistemaScalarFieldEnum = {
  id: 'id',
  chave_configuracao: 'chave_configuracao',
  valor_configuracao: 'valor_configuracao',
  tipo_configuracao: 'tipo_configuracao',
  descricao: 'descricao',
  sistema: 'sistema',
  atualizado_em: 'atualizado_em',
  atualizado_por: 'atualizado_por'
} as const

export type Configuracoes_sistemaScalarFieldEnum = (typeof Configuracoes_sistemaScalarFieldEnum)[keyof typeof Configuracoes_sistemaScalarFieldEnum]


export const FaturasScalarFieldEnum = {
  id: 'id',
  numero_fatura: 'numero_fatura',
  cliente_id: 'cliente_id',
  ordem_trabalho_id: 'ordem_trabalho_id',
  data_emissao: 'data_emissao',
  data_vencimento: 'data_vencimento',
  data_pagamento: 'data_pagamento',
  estado: 'estado',
  subtotal: 'subtotal',
  valor_imposto: 'valor_imposto',
  valor_desconto: 'valor_desconto',
  valor_total: 'valor_total',
  valor_pago: 'valor_pago',
  notas: 'notas',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em',
  criado_por: 'criado_por'
} as const

export type FaturasScalarFieldEnum = (typeof FaturasScalarFieldEnum)[keyof typeof FaturasScalarFieldEnum]


export const FornecedoresScalarFieldEnum = {
  id: 'id',
  nome: 'nome',
  pessoa_contato: 'pessoa_contato',
  email: 'email',
  telefone: 'telefone',
  endereco: 'endereco',
  nif: 'nif',
  termos_pagamento: 'termos_pagamento',
  ativo: 'ativo',
  notas: 'notas',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em',
  criado_por: 'criado_por'
} as const

export type FornecedoresScalarFieldEnum = (typeof FornecedoresScalarFieldEnum)[keyof typeof FornecedoresScalarFieldEnum]


export const Historico_cartao_kanbanScalarFieldEnum = {
  id: 'id',
  cartao_id: 'cartao_id',
  coluna_origem_id: 'coluna_origem_id',
  coluna_destino_id: 'coluna_destino_id',
  movido_por: 'movido_por',
  movido_em: 'movido_em',
  notas: 'notas'
} as const

export type Historico_cartao_kanbanScalarFieldEnum = (typeof Historico_cartao_kanbanScalarFieldEnum)[keyof typeof Historico_cartao_kanbanScalarFieldEnum]


export const Itens_faturaScalarFieldEnum = {
  id: 'id',
  fatura_id: 'fatura_id',
  item_ordem_trabalho_id: 'item_ordem_trabalho_id',
  descricao: 'descricao',
  quantidade: 'quantidade',
  preco_unitario: 'preco_unitario',
  valor_desconto: 'valor_desconto',
  valor_imposto: 'valor_imposto',
  valor_total: 'valor_total',
  criado_em: 'criado_em'
} as const

export type Itens_faturaScalarFieldEnum = (typeof Itens_faturaScalarFieldEnum)[keyof typeof Itens_faturaScalarFieldEnum]


export const Itens_orcamentoScalarFieldEnum = {
  id: 'id',
  orcamento_id: 'orcamento_id',
  tipo_item: 'tipo_item',
  servico_id: 'servico_id',
  peca_id: 'peca_id',
  descricao: 'descricao',
  quantidade: 'quantidade',
  preco_unitario: 'preco_unitario',
  percentual_desconto: 'percentual_desconto',
  valor_desconto: 'valor_desconto',
  percentual_imposto: 'percentual_imposto',
  valor_imposto: 'valor_imposto',
  valor_total: 'valor_total',
  notas: 'notas',
  criado_em: 'criado_em'
} as const

export type Itens_orcamentoScalarFieldEnum = (typeof Itens_orcamentoScalarFieldEnum)[keyof typeof Itens_orcamentoScalarFieldEnum]


export const Itens_ordem_trabalhoScalarFieldEnum = {
  id: 'id',
  ordem_trabalho_id: 'ordem_trabalho_id',
  tipo_item: 'tipo_item',
  servico_id: 'servico_id',
  peca_id: 'peca_id',
  descricao: 'descricao',
  quantidade: 'quantidade',
  preco_unitario: 'preco_unitario',
  horas_trabalho: 'horas_trabalho',
  tarifa_horaria: 'tarifa_horaria',
  percentual_desconto: 'percentual_desconto',
  valor_desconto: 'valor_desconto',
  percentual_imposto: 'percentual_imposto',
  valor_imposto: 'valor_imposto',
  valor_total: 'valor_total',
  notas: 'notas',
  criado_em: 'criado_em'
} as const

export type Itens_ordem_trabalhoScalarFieldEnum = (typeof Itens_ordem_trabalhoScalarFieldEnum)[keyof typeof Itens_ordem_trabalhoScalarFieldEnum]


export const Log_auditoriaScalarFieldEnum = {
  id: 'id',
  utilizador_id: 'utilizador_id',
  acao: 'acao',
  nome_tabela: 'nome_tabela',
  id_registo: 'id_registo',
  valores_antigos: 'valores_antigos',
  valores_novos: 'valores_novos',
  endereco_ip: 'endereco_ip',
  agente_utilizador: 'agente_utilizador',
  criado_em: 'criado_em'
} as const

export type Log_auditoriaScalarFieldEnum = (typeof Log_auditoriaScalarFieldEnum)[keyof typeof Log_auditoriaScalarFieldEnum]


export const MecanicosScalarFieldEnum = {
  id: 'id',
  utilizador_id: 'utilizador_id',
  nome: 'nome',
  especialidade: 'especialidade',
  telefone: 'telefone',
  email: 'email',
  tarifa_horaria: 'tarifa_horaria',
  ativo: 'ativo',
  data_contratacao: 'data_contratacao',
  notas: 'notas',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em'
} as const

export type MecanicosScalarFieldEnum = (typeof MecanicosScalarFieldEnum)[keyof typeof MecanicosScalarFieldEnum]


export const OrcamentosScalarFieldEnum = {
  id: 'id',
  ref_orcamento: 'ref_orcamento',
  cliente_id: 'cliente_id',
  veiculo_id: 'veiculo_id',
  preparado_por: 'preparado_por',
  data_emissao: 'data_emissao',
  data_expiracao: 'data_expiracao',
  estado: 'estado',
  total_pecas: 'total_pecas',
  total_mao_obra: 'total_mao_obra',
  total_desconto: 'total_desconto',
  total_imposto: 'total_imposto',
  total_geral: 'total_geral',
  notas: 'notas',
  data_aprovacao: 'data_aprovacao',
  aprovado_por: 'aprovado_por',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em'
} as const

export type OrcamentosScalarFieldEnum = (typeof OrcamentosScalarFieldEnum)[keyof typeof OrcamentosScalarFieldEnum]


export const Ordens_trabalhoScalarFieldEnum = {
  id: 'id',
  ref_ordem_trabalho: 'ref_ordem_trabalho',
  cliente_id: 'cliente_id',
  veiculo_id: 'veiculo_id',
  mecanico_id: 'mecanico_id',
  orcamento_id: 'orcamento_id',
  agendamento_id: 'agendamento_id',
  data_inicio: 'data_inicio',
  data_conclusao: 'data_conclusao',
  estado: 'estado',
  quilometragem_servico: 'quilometragem_servico',
  descricao_problema: 'descricao_problema',
  trabalho_realizado: 'trabalho_realizado',
  recomendacoes: 'recomendacoes',
  total_pecas: 'total_pecas',
  total_mao_obra: 'total_mao_obra',
  total_desconto: 'total_desconto',
  total_imposto: 'total_imposto',
  total_geral: 'total_geral',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em',
  criado_por: 'criado_por',
  atualizado_por: 'atualizado_por'
} as const

export type Ordens_trabalhoScalarFieldEnum = (typeof Ordens_trabalhoScalarFieldEnum)[keyof typeof Ordens_trabalhoScalarFieldEnum]


export const PagamentosScalarFieldEnum = {
  id: 'id',
  fatura_id: 'fatura_id',
  data_pagamento: 'data_pagamento',
  valor: 'valor',
  metodo_pagamento: 'metodo_pagamento',
  referencia: 'referencia',
  notas: 'notas',
  criado_em: 'criado_em',
  criado_por: 'criado_por'
} as const

export type PagamentosScalarFieldEnum = (typeof PagamentosScalarFieldEnum)[keyof typeof PagamentosScalarFieldEnum]


export const PecasScalarFieldEnum = {
  id: 'id',
  referencia: 'referencia',
  nome: 'nome',
  descricao: 'descricao',
  categoria: 'categoria',
  fornecedor_id: 'fornecedor_id',
  custo_unitario: 'custo_unitario',
  preco_venda: 'preco_venda',
  quantidade_stock: 'quantidade_stock',
  nivel_stock_minimo: 'nivel_stock_minimo',
  nivel_stock_maximo: 'nivel_stock_maximo',
  localizacao: 'localizacao',
  veiculos_compativeis: 'veiculos_compativeis',
  ativo: 'ativo',
  notas: 'notas',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em',
  criado_por: 'criado_por'
} as const

export type PecasScalarFieldEnum = (typeof PecasScalarFieldEnum)[keyof typeof PecasScalarFieldEnum]


export const Pecas_ordem_trabalhoScalarFieldEnum = {
  id: 'id',
  ordem_trabalho_id: 'ordem_trabalho_id',
  peca_id: 'peca_id',
  quantidade_utilizada: 'quantidade_utilizada',
  custo_unitario: 'custo_unitario',
  custo_total: 'custo_total',
  notas: 'notas',
  criado_em: 'criado_em'
} as const

export type Pecas_ordem_trabalhoScalarFieldEnum = (typeof Pecas_ordem_trabalhoScalarFieldEnum)[keyof typeof Pecas_ordem_trabalhoScalarFieldEnum]


export const ServicosScalarFieldEnum = {
  id: 'id',
  categoria_id: 'categoria_id',
  nome: 'nome',
  descricao: 'descricao',
  preco_base: 'preco_base',
  duracao_estimada: 'duracao_estimada',
  requer_pecas: 'requer_pecas',
  ativo: 'ativo',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em'
} as const

export type ServicosScalarFieldEnum = (typeof ServicosScalarFieldEnum)[keyof typeof ServicosScalarFieldEnum]


export const Transacoes_pecasScalarFieldEnum = {
  id: 'id',
  peca_id: 'peca_id',
  tipo_transacao: 'tipo_transacao',
  quantidade: 'quantidade',
  custo_unitario: 'custo_unitario',
  custo_total: 'custo_total',
  documento_referencia: 'documento_referencia',
  fornecedor_id: 'fornecedor_id',
  notas: 'notas',
  criado_em: 'criado_em',
  criado_por: 'criado_por'
} as const

export type Transacoes_pecasScalarFieldEnum = (typeof Transacoes_pecasScalarFieldEnum)[keyof typeof Transacoes_pecasScalarFieldEnum]


export const UtilizadoresScalarFieldEnum = {
  id: 'id',
  nome_utilizador: 'nome_utilizador',
  email: 'email',
  hash_palavra_passe: 'hash_palavra_passe',
  nome_completo: 'nome_completo',
  papel: 'papel',
  ativo: 'ativo',
  ultimo_login: 'ultimo_login',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em'
} as const

export type UtilizadoresScalarFieldEnum = (typeof UtilizadoresScalarFieldEnum)[keyof typeof UtilizadoresScalarFieldEnum]


export const VeiculosScalarFieldEnum = {
  id: 'id',
  cliente_id: 'cliente_id',
  marca: 'marca',
  modelo: 'modelo',
  matricula: 'matricula',
  ano: 'ano',
  numero_chassis: 'numero_chassis',
  tipo_motor: 'tipo_motor',
  tipo_combustivel: 'tipo_combustivel',
  estado: 'estado',
  quilometragem: 'quilometragem',
  ultima_intervencao: 'ultima_intervencao',
  proxima_revisao: 'proxima_revisao',
  companhia_seguros: 'companhia_seguros',
  apolice_seguro: 'apolice_seguro',
  validade_seguro: 'validade_seguro',
  notas: 'notas',
  criado_em: 'criado_em',
  atualizado_em: 'atualizado_em'
} as const

export type VeiculosScalarFieldEnum = (typeof VeiculosScalarFieldEnum)[keyof typeof VeiculosScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const agendamentosOrderByRelevanceFieldEnum = {
  titulo: 'titulo',
  descricao: 'descricao',
  estado: 'estado',
  prioridade: 'prioridade',
  notas: 'notas'
} as const

export type agendamentosOrderByRelevanceFieldEnum = (typeof agendamentosOrderByRelevanceFieldEnum)[keyof typeof agendamentosOrderByRelevanceFieldEnum]


export const cartoes_kanbanOrderByRelevanceFieldEnum = {
  titulo: 'titulo',
  descricao: 'descricao',
  prioridade: 'prioridade',
  etiquetas: 'etiquetas'
} as const

export type cartoes_kanbanOrderByRelevanceFieldEnum = (typeof cartoes_kanbanOrderByRelevanceFieldEnum)[keyof typeof cartoes_kanbanOrderByRelevanceFieldEnum]


export const categorias_servicoOrderByRelevanceFieldEnum = {
  nome: 'nome',
  descricao: 'descricao'
} as const

export type categorias_servicoOrderByRelevanceFieldEnum = (typeof categorias_servicoOrderByRelevanceFieldEnum)[keyof typeof categorias_servicoOrderByRelevanceFieldEnum]


export const clientesOrderByRelevanceFieldEnum = {
  nome: 'nome',
  email: 'email',
  telefone: 'telefone',
  nif: 'nif',
  endereco: 'endereco',
  notas: 'notas'
} as const

export type clientesOrderByRelevanceFieldEnum = (typeof clientesOrderByRelevanceFieldEnum)[keyof typeof clientesOrderByRelevanceFieldEnum]


export const colunas_kanbanOrderByRelevanceFieldEnum = {
  nome: 'nome',
  descricao: 'descricao',
  cor: 'cor'
} as const

export type colunas_kanbanOrderByRelevanceFieldEnum = (typeof colunas_kanbanOrderByRelevanceFieldEnum)[keyof typeof colunas_kanbanOrderByRelevanceFieldEnum]


export const configuracoes_sistemaOrderByRelevanceFieldEnum = {
  chave_configuracao: 'chave_configuracao',
  valor_configuracao: 'valor_configuracao',
  tipo_configuracao: 'tipo_configuracao',
  descricao: 'descricao'
} as const

export type configuracoes_sistemaOrderByRelevanceFieldEnum = (typeof configuracoes_sistemaOrderByRelevanceFieldEnum)[keyof typeof configuracoes_sistemaOrderByRelevanceFieldEnum]


export const faturasOrderByRelevanceFieldEnum = {
  numero_fatura: 'numero_fatura',
  estado: 'estado',
  notas: 'notas'
} as const

export type faturasOrderByRelevanceFieldEnum = (typeof faturasOrderByRelevanceFieldEnum)[keyof typeof faturasOrderByRelevanceFieldEnum]


export const fornecedoresOrderByRelevanceFieldEnum = {
  nome: 'nome',
  pessoa_contato: 'pessoa_contato',
  email: 'email',
  telefone: 'telefone',
  endereco: 'endereco',
  nif: 'nif',
  termos_pagamento: 'termos_pagamento',
  notas: 'notas'
} as const

export type fornecedoresOrderByRelevanceFieldEnum = (typeof fornecedoresOrderByRelevanceFieldEnum)[keyof typeof fornecedoresOrderByRelevanceFieldEnum]


export const historico_cartao_kanbanOrderByRelevanceFieldEnum = {
  notas: 'notas'
} as const

export type historico_cartao_kanbanOrderByRelevanceFieldEnum = (typeof historico_cartao_kanbanOrderByRelevanceFieldEnum)[keyof typeof historico_cartao_kanbanOrderByRelevanceFieldEnum]


export const itens_faturaOrderByRelevanceFieldEnum = {
  descricao: 'descricao'
} as const

export type itens_faturaOrderByRelevanceFieldEnum = (typeof itens_faturaOrderByRelevanceFieldEnum)[keyof typeof itens_faturaOrderByRelevanceFieldEnum]


export const itens_orcamentoOrderByRelevanceFieldEnum = {
  tipo_item: 'tipo_item',
  descricao: 'descricao',
  notas: 'notas'
} as const

export type itens_orcamentoOrderByRelevanceFieldEnum = (typeof itens_orcamentoOrderByRelevanceFieldEnum)[keyof typeof itens_orcamentoOrderByRelevanceFieldEnum]


export const itens_ordem_trabalhoOrderByRelevanceFieldEnum = {
  tipo_item: 'tipo_item',
  descricao: 'descricao',
  notas: 'notas'
} as const

export type itens_ordem_trabalhoOrderByRelevanceFieldEnum = (typeof itens_ordem_trabalhoOrderByRelevanceFieldEnum)[keyof typeof itens_ordem_trabalhoOrderByRelevanceFieldEnum]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const log_auditoriaOrderByRelevanceFieldEnum = {
  acao: 'acao',
  nome_tabela: 'nome_tabela',
  endereco_ip: 'endereco_ip',
  agente_utilizador: 'agente_utilizador'
} as const

export type log_auditoriaOrderByRelevanceFieldEnum = (typeof log_auditoriaOrderByRelevanceFieldEnum)[keyof typeof log_auditoriaOrderByRelevanceFieldEnum]


export const mecanicosOrderByRelevanceFieldEnum = {
  nome: 'nome',
  especialidade: 'especialidade',
  telefone: 'telefone',
  email: 'email',
  notas: 'notas'
} as const

export type mecanicosOrderByRelevanceFieldEnum = (typeof mecanicosOrderByRelevanceFieldEnum)[keyof typeof mecanicosOrderByRelevanceFieldEnum]


export const orcamentosOrderByRelevanceFieldEnum = {
  ref_orcamento: 'ref_orcamento',
  estado: 'estado',
  notas: 'notas'
} as const

export type orcamentosOrderByRelevanceFieldEnum = (typeof orcamentosOrderByRelevanceFieldEnum)[keyof typeof orcamentosOrderByRelevanceFieldEnum]


export const ordens_trabalhoOrderByRelevanceFieldEnum = {
  ref_ordem_trabalho: 'ref_ordem_trabalho',
  estado: 'estado',
  descricao_problema: 'descricao_problema',
  trabalho_realizado: 'trabalho_realizado',
  recomendacoes: 'recomendacoes'
} as const

export type ordens_trabalhoOrderByRelevanceFieldEnum = (typeof ordens_trabalhoOrderByRelevanceFieldEnum)[keyof typeof ordens_trabalhoOrderByRelevanceFieldEnum]


export const pagamentosOrderByRelevanceFieldEnum = {
  metodo_pagamento: 'metodo_pagamento',
  referencia: 'referencia',
  notas: 'notas'
} as const

export type pagamentosOrderByRelevanceFieldEnum = (typeof pagamentosOrderByRelevanceFieldEnum)[keyof typeof pagamentosOrderByRelevanceFieldEnum]


export const pecasOrderByRelevanceFieldEnum = {
  referencia: 'referencia',
  nome: 'nome',
  descricao: 'descricao',
  categoria: 'categoria',
  localizacao: 'localizacao',
  veiculos_compativeis: 'veiculos_compativeis',
  notas: 'notas'
} as const

export type pecasOrderByRelevanceFieldEnum = (typeof pecasOrderByRelevanceFieldEnum)[keyof typeof pecasOrderByRelevanceFieldEnum]


export const pecas_ordem_trabalhoOrderByRelevanceFieldEnum = {
  notas: 'notas'
} as const

export type pecas_ordem_trabalhoOrderByRelevanceFieldEnum = (typeof pecas_ordem_trabalhoOrderByRelevanceFieldEnum)[keyof typeof pecas_ordem_trabalhoOrderByRelevanceFieldEnum]


export const servicosOrderByRelevanceFieldEnum = {
  nome: 'nome',
  descricao: 'descricao'
} as const

export type servicosOrderByRelevanceFieldEnum = (typeof servicosOrderByRelevanceFieldEnum)[keyof typeof servicosOrderByRelevanceFieldEnum]


export const transacoes_pecasOrderByRelevanceFieldEnum = {
  tipo_transacao: 'tipo_transacao',
  documento_referencia: 'documento_referencia',
  notas: 'notas'
} as const

export type transacoes_pecasOrderByRelevanceFieldEnum = (typeof transacoes_pecasOrderByRelevanceFieldEnum)[keyof typeof transacoes_pecasOrderByRelevanceFieldEnum]


export const utilizadoresOrderByRelevanceFieldEnum = {
  nome_utilizador: 'nome_utilizador',
  email: 'email',
  hash_palavra_passe: 'hash_palavra_passe',
  nome_completo: 'nome_completo'
} as const

export type utilizadoresOrderByRelevanceFieldEnum = (typeof utilizadoresOrderByRelevanceFieldEnum)[keyof typeof utilizadoresOrderByRelevanceFieldEnum]


export const veiculosOrderByRelevanceFieldEnum = {
  marca: 'marca',
  modelo: 'modelo',
  matricula: 'matricula',
  numero_chassis: 'numero_chassis',
  tipo_motor: 'tipo_motor',
  tipo_combustivel: 'tipo_combustivel',
  estado: 'estado',
  companhia_seguros: 'companhia_seguros',
  apolice_seguro: 'apolice_seguro',
  notas: 'notas'
} as const

export type veiculosOrderByRelevanceFieldEnum = (typeof veiculosOrderByRelevanceFieldEnum)[keyof typeof veiculosOrderByRelevanceFieldEnum]



/**
 * Field references
 */


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'clientes_perfil'
 */
export type Enumclientes_perfilFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'clientes_perfil'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'utilizadores_papel'
 */
export type Enumutilizadores_papelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'utilizadores_papel'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  agendamentos?: Prisma.agendamentosOmit
  cartoes_kanban?: Prisma.cartoes_kanbanOmit
  categorias_servico?: Prisma.categorias_servicoOmit
  clientes?: Prisma.clientesOmit
  colunas_kanban?: Prisma.colunas_kanbanOmit
  configuracoes_sistema?: Prisma.configuracoes_sistemaOmit
  faturas?: Prisma.faturasOmit
  fornecedores?: Prisma.fornecedoresOmit
  historico_cartao_kanban?: Prisma.historico_cartao_kanbanOmit
  itens_fatura?: Prisma.itens_faturaOmit
  itens_orcamento?: Prisma.itens_orcamentoOmit
  itens_ordem_trabalho?: Prisma.itens_ordem_trabalhoOmit
  log_auditoria?: Prisma.log_auditoriaOmit
  mecanicos?: Prisma.mecanicosOmit
  orcamentos?: Prisma.orcamentosOmit
  ordens_trabalho?: Prisma.ordens_trabalhoOmit
  pagamentos?: Prisma.pagamentosOmit
  pecas?: Prisma.pecasOmit
  pecas_ordem_trabalho?: Prisma.pecas_ordem_trabalhoOmit
  servicos?: Prisma.servicosOmit
  transacoes_pecas?: Prisma.transacoes_pecasOmit
  utilizadores?: Prisma.utilizadoresOmit
  veiculos?: Prisma.veiculosOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

